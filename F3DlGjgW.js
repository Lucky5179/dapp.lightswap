import{d as be}from"./assets/index-POi8GhpC.js";import{c as g,b as Y,a as M,d as E}from"./BY6RoX_X.js";(function(){try{var e=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},t=new e.Error().stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="2635c7b9-f098-445f-ad49-9e38d4a3dc3e",e._sentryDebugIdIdentifier="sentry-dbid-2635c7b9-f098-445f-ad49-9e38d4a3dc3e")}catch{}})();function he(e,t){for(var r=0;r<t.length;r++){const n=t[r];if(typeof n!="string"&&!Array.isArray(n)){for(const o in n)if(o!=="default"&&!(o in e)){const i=Object.getOwnPropertyDescriptor(n,o);i&&Object.defineProperty(e,o,i.get?i:{enumerable:!0,get:()=>n[o]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var K={},y={},c={},T={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.isMultisigThresholdPubkey=e.isSinglePubkey=e.pubkeyType=e.isSecp256k1Pubkey=e.isEd25519Pubkey=void 0;function t(i){return i.type==="tendermint/PubKeyEd25519"}e.isEd25519Pubkey=t;function r(i){return i.type==="tendermint/PubKeySecp256k1"}e.isSecp256k1Pubkey=r,e.pubkeyType={secp256k1:"tendermint/PubKeySecp256k1",ed25519:"tendermint/PubKeyEd25519",sr25519:"tendermint/PubKeySr25519",multisigThreshold:"tendermint/PubKeyMultisigThreshold"};function n(i){return[e.pubkeyType.ed25519,e.pubkeyType.secp256k1,e.pubkeyType.sr25519].includes(i.type)}e.isSinglePubkey=n;function o(i){return i.type==="tendermint/PubKeyMultisigThreshold"}e.isMultisigThresholdPubkey=o})(T),Object.defineProperty(c,"__esModule",{value:!0}),c.encodeBech32Pubkey=c.encodeAminoPubkey=c.decodeBech32Pubkey=c.decodeAminoPubkey=c.encodeEd25519Pubkey=c.encodeSecp256k1Pubkey=void 0;const p=g,me=M,x=Y,h=T;function ge(e){if(e.length!==33||e[0]!==2&&e[0]!==3)throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");return{type:h.pubkeyType.secp256k1,value:(0,p.toBase64)(e)}}c.encodeSecp256k1Pubkey=ge;function ke(e){if(e.length!==32)throw new Error("Ed25519 public key must be 32 bytes long");return{type:h.pubkeyType.ed25519,value:(0,p.toBase64)(e)}}c.encodeEd25519Pubkey=ke;const W=(0,p.fromHex)("eb5ae98721"),J=(0,p.fromHex)("1624de6420"),ee=(0,p.fromHex)("0dfb100520"),R=(0,p.fromHex)("22c1f7e2");function H(e){if((0,x.arrayContentStartsWith)(e,W)){const t=e.slice(W.length);if(t.length!==33)throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");return{type:h.pubkeyType.secp256k1,value:(0,p.toBase64)(t)}}else if((0,x.arrayContentStartsWith)(e,J)){const t=e.slice(J.length);if(t.length!==32)throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");return{type:h.pubkeyType.ed25519,value:(0,p.toBase64)(t)}}else if((0,x.arrayContentStartsWith)(e,ee)){const t=e.slice(ee.length);if(t.length!==32)throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");return{type:h.pubkeyType.sr25519,value:(0,p.toBase64)(t)}}else{if((0,x.arrayContentStartsWith)(e,R))return Pe(e);throw new Error("Unsupported public key type. Amino data starts with: "+(0,p.toHex)(e.slice(0,5)))}}c.decodeAminoPubkey=H;function we(e){const{data:t}=(0,p.fromBech32)(e);return H(t)}c.decodeBech32Pubkey=we;function te(e){if(e.length<1)throw new Error("Can't decode varint. EOF");if(e[0]>127)throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");return[e[0],1]}function Pe(e){const t=Array.from(e),r=t.splice(0,R.length);if(!(0,x.arrayContentStartsWith)(r,R))throw new Error("Invalid multisig prefix.");if(t.shift()!=8)throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");const[n,o]=te(t);t.splice(0,o);const i=[];for(;t.length>0;){if(t.shift()!=18)throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");const[u,a]=te(t);if(t.splice(0,a),t.length<u)throw new Error("Invalid multisig data length.");const s=t.splice(0,u),d=H(Uint8Array.from(s));i.push(d)}return{type:h.pubkeyType.multisigThreshold,value:{threshold:n.toString(),pubkeys:i}}}function re(e){const t=me.Uint53.fromString(e.toString()).toNumber();if(t>127)throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");return[t]}function $(e){if((0,h.isMultisigThresholdPubkey)(e)){const t=Array.from(R);t.push(8),t.push(...re(e.value.threshold));for(const r of e.value.pubkeys.map(n=>$(n)))t.push(18),t.push(...re(r.length)),t.push(...r);return new Uint8Array(t)}else{if((0,h.isEd25519Pubkey)(e))return new Uint8Array([...J,...(0,p.fromBase64)(e.value)]);if((0,h.isSecp256k1Pubkey)(e))return new Uint8Array([...W,...(0,p.fromBase64)(e.value)]);throw new Error("Unsupported pubkey type")}}c.encodeAminoPubkey=$;function Se(e,t){return(0,p.toBech32)(t,$(e))}c.encodeBech32Pubkey=Se,Object.defineProperty(y,"__esModule",{value:!0}),y.pubkeyToAddress=y.pubkeyToRawAddress=y.rawSecp256k1PubkeyToRawAddress=y.rawEd25519PubkeyToRawAddress=void 0;const I=E,L=g,ve=c,G=T;function ne(e){if(e.length!==32)throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);return(0,I.sha256)(e).slice(0,20)}y.rawEd25519PubkeyToRawAddress=ne;function oe(e){if(e.length!==33)throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);return(0,I.ripemd160)((0,I.sha256)(e))}y.rawSecp256k1PubkeyToRawAddress=oe;function ie(e){if((0,G.isSecp256k1Pubkey)(e)){const t=(0,L.fromBase64)(e.value);return oe(t)}else if((0,G.isEd25519Pubkey)(e)){const t=(0,L.fromBase64)(e.value);return ne(t)}else if((0,G.isMultisigThresholdPubkey)(e)){const t=(0,ve.encodeAminoPubkey)(e);return(0,I.sha256)(t).slice(0,20)}else throw new Error("Unsupported public key type")}y.pubkeyToRawAddress=ie;function Ae(e,t){return(0,L.toBech32)(t,ie(e))}y.pubkeyToAddress=Ae;var b={};Object.defineProperty(b,"__esModule",{value:!0}),b.addCoins=b.parseCoins=b.coins=b.coin=void 0;const V=M;function se(e,t){let r;if(typeof e=="number")try{r=new V.Uint53(e).toString()}catch{throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.")}else{if(!e.match(/^[0-9]+$/))throw new Error("Invalid unsigned integer string format");r=e.replace(/^0*/,"")||"0"}return{amount:r,denom:t}}b.coin=se;function Ee(e,t){return[se(e,t)]}b.coins=Ee;function Te(e){return e.replace(/\s/g,"").split(",").filter(Boolean).map(t=>{const r=t.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);if(!r)throw new Error("Got an invalid coin string");return{amount:r[1].replace(/^0+/,"")||"0",denom:r[2]}})}b.parseCoins=Te;function xe(e,t){if(e.denom!==t.denom)throw new Error("Trying to add two coins with different denoms");return{amount:V.Decimal.fromAtomics(e.amount,0).plus(V.Decimal.fromAtomics(t.amount,0)).atomics,denom:e.denom}}b.addCoins=xe;var P={};Object.defineProperty(P,"__esModule",{value:!0}),P.createMultisigThresholdPubkey=P.compareArrays=void 0;const ae=g,Oe=M,ue=y;function ce(e,t){const r=(0,ae.toHex)(e),n=(0,ae.toHex)(t);return r===n?0:r<n?-1:1}P.compareArrays=ce;function je(e,t,r=!1){const n=new Oe.Uint53(t);if(n.toNumber()>e.length)throw new Error(`Threshold k = ${n.toNumber()} exceeds number of keys n = ${e.length}`);const o=r?e:Array.from(e).sort((i,u)=>{const a=(0,ue.pubkeyToRawAddress)(i),s=(0,ue.pubkeyToRawAddress)(u);return ce(a,s)});return{type:"tendermint/PubKeyMultisigThreshold",value:{threshold:n.toString(),pubkeys:o}}}P.createMultisigThresholdPubkey=je;var D={};Object.defineProperty(D,"__esModule",{value:!0}),D.omitDefault=void 0;function _e(e){switch(typeof e){case"string":return e===""?void 0:e;case"number":return e===0?void 0:e;case"bigint":return e===BigInt(0)?void 0:e;case"boolean":return e||void 0;default:throw new Error(`Got unsupported type '${typeof e}'`)}}D.omitDefault=_e;var O={};Object.defineProperty(O,"__esModule",{value:!0}),O.makeCosmoshubPath=void 0;const j=E;function Be(e){return[j.Slip10RawIndex.hardened(44),j.Slip10RawIndex.hardened(118),j.Slip10RawIndex.hardened(0),j.Slip10RawIndex.normal(0),j.Slip10RawIndex.normal(e)]}O.makeCosmoshubPath=Be;var S={},k={};Object.defineProperty(k,"__esModule",{value:!0}),k.decodeSignature=k.encodeSecp256k1Signature=void 0;const F=g,Ce=c,Me=T;function Ke(e,t){if(t.length!==64)throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");return{pub_key:(0,Ce.encodeSecp256k1Pubkey)(e),signature:(0,F.toBase64)(t)}}k.encodeSecp256k1Signature=Ke;function Re(e){switch(e.pub_key.type){case Me.pubkeyType.secp256k1:return{pubkey:(0,F.fromBase64)(e.pub_key.value),signature:(0,F.fromBase64)(e.signature)};default:throw new Error("Unsupported pubkey type")}}k.decodeSignature=Re;var l={};Object.defineProperty(l,"__esModule",{value:!0}),l.serializeSignDoc=l.escapeCharacters=l.makeSignDoc=l.sortedJsonStringify=void 0;const Ie=g,de=M;function X(e){if(typeof e!="object"||e===null)return e;if(Array.isArray(e))return e.map(X);const t=Object.keys(e).sort(),r={};return t.forEach(n=>{r[n]=X(e[n])}),r}function pe(e){return JSON.stringify(X(e))}l.sortedJsonStringify=pe;function De(e,t,r,n,o,i,u){return{chain_id:r,account_number:de.Uint53.fromString(o.toString()).toString(),sequence:de.Uint53.fromString(i.toString()).toString(),fee:t,msgs:e,memo:n||"",...u&&{timeout_height:u.toString()}}}l.makeSignDoc=De;function ye(e){const t=/&/g,r=/</g,n=/>/g;return e.replace(t,"\\u0026").replace(r,"\\u003c").replace(n,"\\u003e")}l.escapeCharacters=ye;function Ue(e){const t=ye(pe(e));return(0,Ie.toUtf8)(t)}l.serializeSignDoc=Ue;var Z={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.decrypt=e.encrypt=e.supportedAlgorithms=e.executeKdf=e.cosmjsSalt=void 0;const t=E,r=g;e.cosmjsSalt=(0,r.toAscii)("The CosmJS salt.");async function n(u,a){switch(a.algorithm){case"argon2id":{const s=a.params;if(!(0,t.isArgon2idOptions)(s))throw new Error("Invalid format of argon2id params");return t.Argon2id.execute(u,e.cosmjsSalt,s)}default:throw new Error("Unsupported KDF algorithm")}}e.executeKdf=n,e.supportedAlgorithms={xchacha20poly1305Ietf:"xchacha20poly1305-ietf"};async function o(u,a,s){switch(s.algorithm){case e.supportedAlgorithms.xchacha20poly1305Ietf:{const d=t.Random.getBytes(t.xchacha20NonceLength);return new Uint8Array([...d,...await t.Xchacha20poly1305Ietf.encrypt(u,a,d)])}default:throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`)}}e.encrypt=o;async function i(u,a,s){switch(s.algorithm){case e.supportedAlgorithms.xchacha20poly1305Ietf:{const d=u.slice(0,t.xchacha20NonceLength);return t.Xchacha20poly1305Ietf.decrypt(u.slice(t.xchacha20NonceLength),a,d)}default:throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`)}}e.decrypt=i})(Z),Object.defineProperty(S,"__esModule",{value:!0}),S.Secp256k1HdWallet=S.extractKdfConfiguration=void 0;const f=E,_=g,v=Y,Ne=y,ze=O,We=k,Je=l,B=Z,U="secp256k1wallet-v1",He={algorithm:"argon2id",params:{outputLength:32,opsLimit:24,memLimitKib:12*1024}};function $e(e){return!(!(0,v.isNonNullObject)(e)||typeof e.hdPath!="string"||typeof e.prefix!="string")}function Le(e){return e.kdf}function Ge(e){const t=JSON.parse(e);if(!(0,v.isNonNullObject)(t))throw new Error("Root document is not an object.");switch(t.type){case U:return Le(t);default:throw new Error("Unsupported serialization type")}}S.extractKdfConfiguration=Ge;const le={bip39Password:"",hdPaths:[(0,ze.makeCosmoshubPath)(0)],prefix:"cosmos"};class w{static async fromMnemonic(t,r={}){const n=new f.EnglishMnemonic(t),o=await f.Bip39.mnemonicToSeed(n,r.bip39Password);return new w(n,{...r,seed:o})}static async generate(t=12,r={}){const n=4*Math.floor(11*t/33),o=f.Random.getBytes(n),i=f.Bip39.encode(o);return w.fromMnemonic(i.toString(),r)}static async deserialize(t,r){const n=JSON.parse(t);if(!(0,v.isNonNullObject)(n))throw new Error("Root document is not an object.");switch(n.type){case U:return w.deserializeTypeV1(t,r);default:throw new Error("Unsupported serialization type")}}static async deserializeWithEncryptionKey(t,r){const n=JSON.parse(t);if(!(0,v.isNonNullObject)(n))throw new Error("Root document is not an object.");const o=n;switch(o.type){case U:{const i=await(0,B.decrypt)((0,_.fromBase64)(o.data),r,o.encryption),u=JSON.parse((0,_.fromUtf8)(i)),{mnemonic:a,accounts:s}=u;if((0,v.assert)(typeof a=="string"),!Array.isArray(s))throw new Error("Property 'accounts' is not an array");if(!s.every(m=>$e(m)))throw new Error("Account is not in the correct format.");const d=s[0].prefix;if(!s.every(({prefix:m})=>m===d))throw new Error("Accounts do not all have the same prefix");const C=s.map(({hdPath:m})=>(0,f.stringToPath)(m));return w.fromMnemonic(a,{hdPaths:C,prefix:d})}default:throw new Error("Unsupported serialization type")}}static async deserializeTypeV1(t,r){const n=JSON.parse(t);if(!(0,v.isNonNullObject)(n))throw new Error("Root document is not an object.");const o=await(0,B.executeKdf)(r,n.kdf);return w.deserializeWithEncryptionKey(t,o)}constructor(t,r){const n=r.hdPaths??le.hdPaths,o=r.prefix??le.prefix;this.secret=t,this.seed=r.seed,this.accounts=n.map(i=>({hdPath:i,prefix:o}))}get mnemonic(){return this.secret.toString()}async getAccounts(){return(await this.getAccountsWithPrivkeys()).map(({algo:t,pubkey:r,address:n})=>({algo:t,pubkey:r,address:n}))}async signAmino(t,r){const n=(await this.getAccountsWithPrivkeys()).find(({address:d})=>d===t);if(n===void 0)throw new Error(`Address ${t} not found in wallet`);const{privkey:o,pubkey:i}=n,u=(0,f.sha256)((0,Je.serializeSignDoc)(r)),a=await f.Secp256k1.createSignature(u,o),s=new Uint8Array([...a.r(32),...a.s(32)]);return{signed:r,signature:(0,We.encodeSecp256k1Signature)(i,s)}}async serialize(t){const r=He,n=await(0,B.executeKdf)(t,r);return this.serializeWithEncryptionKey(n,r)}async serializeWithEncryptionKey(t,r){const n={mnemonic:this.mnemonic,accounts:this.accounts.map(({hdPath:s,prefix:d})=>({hdPath:(0,f.pathToString)(s),prefix:d}))},o=(0,_.toUtf8)(JSON.stringify(n)),i={algorithm:B.supportedAlgorithms.xchacha20poly1305Ietf},u=await(0,B.encrypt)(o,t,i),a={type:U,kdf:r,encryption:i,data:(0,_.toBase64)(u)};return JSON.stringify(a)}async getKeyPair(t){const{privkey:r}=f.Slip10.derivePath(f.Slip10Curve.Secp256k1,this.seed,t),{pubkey:n}=await f.Secp256k1.makeKeypair(r);return{privkey:r,pubkey:f.Secp256k1.compressPubkey(n)}}async getAccountsWithPrivkeys(){return Promise.all(this.accounts.map(async({hdPath:t,prefix:r})=>{const{privkey:n,pubkey:o}=await this.getKeyPair(t),i=(0,_.toBech32)(r,(0,Ne.rawSecp256k1PubkeyToRawAddress)(o));return{algo:"secp256k1",privkey:n,pubkey:o,address:i}}))}}S.Secp256k1HdWallet=w;var N={};Object.defineProperty(N,"__esModule",{value:!0}),N.Secp256k1Wallet=void 0;const z=E,Ve=g,Fe=y,Xe=k,Ze=l;class q{static async fromKey(t,r="cosmos"){const n=(await z.Secp256k1.makeKeypair(t)).pubkey;return new q(t,z.Secp256k1.compressPubkey(n),r)}constructor(t,r,n){this.privkey=t,this.pubkey=r,this.prefix=n}get address(){return(0,Ve.toBech32)(this.prefix,(0,Fe.rawSecp256k1PubkeyToRawAddress)(this.pubkey))}async getAccounts(){return[{algo:"secp256k1",address:this.address,pubkey:this.pubkey}]}async signAmino(t,r){if(t!==this.address)throw new Error(`Address ${t} not found in wallet`);const n=new z.Sha256((0,Ze.serializeSignDoc)(r)).digest(),o=await z.Secp256k1.createSignature(n,this.privkey),i=new Uint8Array([...o.r(32),...o.s(32)]);return{signed:r,signature:(0,Xe.encodeSecp256k1Signature)(this.pubkey,i)}}}N.Secp256k1Wallet=q;var A={};Object.defineProperty(A,"__esModule",{value:!0}),A.makeStdTx=A.isStdTx=void 0;function qe(e){const{memo:t,msg:r,fee:n,signatures:o}=e;return typeof t=="string"&&Array.isArray(r)&&typeof n=="object"&&Array.isArray(o)}A.isStdTx=qe;function Qe(e,t){return{msg:e.msgs,fee:e.fee,memo:e.memo,signatures:Array.isArray(t)?t:[t]}}A.makeStdTx=Qe,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.executeKdf=e.makeStdTx=e.isStdTx=e.serializeSignDoc=e.makeSignDoc=e.encodeSecp256k1Signature=e.decodeSignature=e.Secp256k1Wallet=e.Secp256k1HdWallet=e.extractKdfConfiguration=e.pubkeyType=e.isSinglePubkey=e.isSecp256k1Pubkey=e.isMultisigThresholdPubkey=e.isEd25519Pubkey=e.makeCosmoshubPath=e.omitDefault=e.createMultisigThresholdPubkey=e.encodeSecp256k1Pubkey=e.encodeEd25519Pubkey=e.encodeBech32Pubkey=e.encodeAminoPubkey=e.decodeBech32Pubkey=e.decodeAminoPubkey=e.parseCoins=e.coins=e.coin=e.addCoins=e.rawSecp256k1PubkeyToRawAddress=e.rawEd25519PubkeyToRawAddress=e.pubkeyToRawAddress=e.pubkeyToAddress=void 0;var t=y;Object.defineProperty(e,"pubkeyToAddress",{enumerable:!0,get:function(){return t.pubkeyToAddress}}),Object.defineProperty(e,"pubkeyToRawAddress",{enumerable:!0,get:function(){return t.pubkeyToRawAddress}}),Object.defineProperty(e,"rawEd25519PubkeyToRawAddress",{enumerable:!0,get:function(){return t.rawEd25519PubkeyToRawAddress}}),Object.defineProperty(e,"rawSecp256k1PubkeyToRawAddress",{enumerable:!0,get:function(){return t.rawSecp256k1PubkeyToRawAddress}});var r=b;Object.defineProperty(e,"addCoins",{enumerable:!0,get:function(){return r.addCoins}}),Object.defineProperty(e,"coin",{enumerable:!0,get:function(){return r.coin}}),Object.defineProperty(e,"coins",{enumerable:!0,get:function(){return r.coins}}),Object.defineProperty(e,"parseCoins",{enumerable:!0,get:function(){return r.parseCoins}});var n=c;Object.defineProperty(e,"decodeAminoPubkey",{enumerable:!0,get:function(){return n.decodeAminoPubkey}}),Object.defineProperty(e,"decodeBech32Pubkey",{enumerable:!0,get:function(){return n.decodeBech32Pubkey}}),Object.defineProperty(e,"encodeAminoPubkey",{enumerable:!0,get:function(){return n.encodeAminoPubkey}}),Object.defineProperty(e,"encodeBech32Pubkey",{enumerable:!0,get:function(){return n.encodeBech32Pubkey}}),Object.defineProperty(e,"encodeEd25519Pubkey",{enumerable:!0,get:function(){return n.encodeEd25519Pubkey}}),Object.defineProperty(e,"encodeSecp256k1Pubkey",{enumerable:!0,get:function(){return n.encodeSecp256k1Pubkey}});var o=P;Object.defineProperty(e,"createMultisigThresholdPubkey",{enumerable:!0,get:function(){return o.createMultisigThresholdPubkey}});var i=D;Object.defineProperty(e,"omitDefault",{enumerable:!0,get:function(){return i.omitDefault}});var u=O;Object.defineProperty(e,"makeCosmoshubPath",{enumerable:!0,get:function(){return u.makeCosmoshubPath}});var a=T;Object.defineProperty(e,"isEd25519Pubkey",{enumerable:!0,get:function(){return a.isEd25519Pubkey}}),Object.defineProperty(e,"isMultisigThresholdPubkey",{enumerable:!0,get:function(){return a.isMultisigThresholdPubkey}}),Object.defineProperty(e,"isSecp256k1Pubkey",{enumerable:!0,get:function(){return a.isSecp256k1Pubkey}}),Object.defineProperty(e,"isSinglePubkey",{enumerable:!0,get:function(){return a.isSinglePubkey}}),Object.defineProperty(e,"pubkeyType",{enumerable:!0,get:function(){return a.pubkeyType}});var s=S;Object.defineProperty(e,"extractKdfConfiguration",{enumerable:!0,get:function(){return s.extractKdfConfiguration}}),Object.defineProperty(e,"Secp256k1HdWallet",{enumerable:!0,get:function(){return s.Secp256k1HdWallet}});var d=N;Object.defineProperty(e,"Secp256k1Wallet",{enumerable:!0,get:function(){return d.Secp256k1Wallet}});var C=k;Object.defineProperty(e,"decodeSignature",{enumerable:!0,get:function(){return C.decodeSignature}}),Object.defineProperty(e,"encodeSecp256k1Signature",{enumerable:!0,get:function(){return C.encodeSecp256k1Signature}});var m=l;Object.defineProperty(e,"makeSignDoc",{enumerable:!0,get:function(){return m.makeSignDoc}}),Object.defineProperty(e,"serializeSignDoc",{enumerable:!0,get:function(){return m.serializeSignDoc}});var Q=A;Object.defineProperty(e,"isStdTx",{enumerable:!0,get:function(){return Q.isStdTx}}),Object.defineProperty(e,"makeStdTx",{enumerable:!0,get:function(){return Q.makeStdTx}});var fe=Z;Object.defineProperty(e,"executeKdf",{enumerable:!0,get:function(){return fe.executeKdf}})}(K);const Ye=be(K),et=he({__proto__:null,default:Ye},[K]);export{K as b,et as i};
